// RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES
// RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES
// RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES RETORNO DE FUNCÕES

// void main() {
//   saudacoes();

//   String a = agora();
//   print(a);
// }

// void saudacoes() {
//   //void significa que a função não tem nenhum retorno.
//   print('Saudações do Daniel');
//   print('Seja bem-vindo(a)!');
//   print('Agora ${agora()}');
//   //Deve-se colocar {} quando chamar o retorno de uma função em outra função dentro de um print.
// }

// String agora() {
//   // Funcao do tipo String, pois receberá o valor final como String.
//   DateTime agora = DateTime.now();
//   //Variável "agora" recebe o valor do "DateTime.now();
//   return agora.toString();
//   //Retorna e converte o valor de DateTime.now para String.
// }

// PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES
// PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES
// PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES PARÂMETROS DE FUNÇÕES

// void main() {
//   //Por serem parâmetros posicionais, devem se colocar todos em ordem para funcionar...
//   saudacoes('Daniel', sep: '*', mostrarAgora: false);
//   //Estou passando o parâmetro 'Daniel' para a variável "nome", e o parâmetro false para a variável "mostrarAgora"
//   saudacoes('Daniel', mostrarAgora: true, sep: '*');
//   //Substituí os '---' por '***'
// }

// // void saudacoes(String nome, bool mostrarAgora) // quando os parâmetros ficam somente em () eles tem que ser declarados obrigatóriamente na função main principal.
// // void saudacoes(String nome, [bool mostrarAgora = true]) // quando os parâmetros ficam entre [] eles não tem que obrigatoriamente serem declarados, porém eu tenho que obrigatóriamente deixar um valor "PADRÃO"
// // {bool mostrarAgora = true, String sep = '-'} // quando os parâmetros ficam entre {} eles são POSICIONAIS NOMEADOS, não precisa mais declarar na ordem, porém precisa informar qual o parâmetro e o valor que ele recebera.
// void saudacoes(String nome, {bool mostrarAgora = true, String sep = '-'}) {
//   print('-' * 20);
//   // ele imprime o '-' 20 vezes, ficando assim --------------------
//   print('Saudações do $nome');
//   print('Seja bem-vindo(a)!');
//   if (mostrarAgora) {
//     print('Agora ${agora()}');
//   }
// }

// String agora() {
//   DateTime agora = DateTime.now();
//   return agora.toString();
// }

// VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE
// VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE
// VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE // VARIÁVEIS NULLABLE

// void main() {
//   saudacoes('Daniel');
// }

// void saudacoes(
//   String nome, {
//   bool mostrarAgora = true,
//   String? cliente,
//   // ? serve para declarar a variável como null, ou seja, ela recebe o valor de null caso não seja declarado o valor, se não for declarado nenhum valor a ela, ela não poderá ser usada para fazer nenhuma operação!
// }) 

// {
//   print('Saudações do $nome');

//   if (cliente != null) {
//     print('Seja bem-vindo(a)! $cliente');
//   }

//   if (mostrarAgora) {
//     print('Agora: ${agora()}');
//   }
// }

// String agora() {
//   DateTime agora = DateTime.now();
//   return agora.toString();
// }

// CONVERSÃO NULLABLE PARA NON-NULLABLE // CONVERSÃO NULLABLE PARA NON-NULLABLE // CONVERSÃO NULLABLE PARA NON-NULLABLE
// CONVERSÃO NULLABLE PARA NON-NULLABLE // CONVERSÃO NULLABLE PARA NON-NULLABLE // CONVERSÃO NULLABLE PARA NON-NULLABLE
// CONVERSÃO NULLABLE PARA NON-NULLABLE // CONVERSÃO NULLABLE PARA NON-NULLABLE // CONVERSÃO NULLABLE PARA NON-NULLABLE

// void main() {
//   saudacoes('Daniel');
// }

// void saudacoes(
//   String nome, {
//   bool mostrarAgora = true,
//   String? cliente,
// }) {
//   print('Saudações do ${nome.toUpperCase()}'); 
//   // to.UpperCase é um MÉTODO e serve para transformar o texto da variável nome todo em MAIÚSCULO, Obs: Devo colocar a variável e o método dentro de {} para funcionar.

//   String c = cliente ?? 'Não informado';
//   // Essa é uma forma de definir um valor padrão para a variável cliente, que é uma variável nullable, se não fizer isso a variável c não aceitaria receber o valor da variável cliente, pois a variável c é obrigatória ter valor, e a variável cliente não.

//   if (cliente != null) {
//     print('Seja bem-vindo(a)! ${c.toUpperCase()}');
//   }

//   if (cliente != null) {
//     print('Seja bem-vindo(a)! ${cliente.toUpperCase()}');
//     // a variável cliente pode ser nula, então para eu usar o método toUperCase eu devo fazer um if para verificar se ela é diferente de null.
//     // Ou seja, essa é a forma de converter uma variável nullable para non-nullable.
//   }
// }

// RESUMO SOBRE PARÂMETROS // RESUMO SOBRE PARÂMETROS // RESUMO SOBRE PARÂMETROS
// RESUMO SOBRE PARÂMETROS // RESUMO SOBRE PARÂMETROS // RESUMO SOBRE PARÂMETROS
// RESUMO SOBRE PARÂMETROS // RESUMO SOBRE PARÂMETROS // RESUMO SOBRE PARÂMETROS

// void main() {
//   saudacoes('Daniel');
//   funcao('Olá', null, c: null, e: null, d: 'teste');
//   }

// void saudacoes(
//   String nome, {
//   bool mostrarAgora = true,
//   String? cliente,
// }) {
//   print('Saudações do ${nome.toUpperCase()}');

//   String c = cliente ?? 'Não informado';

//   if (cliente != null) {
//     print('Seja bem-vindo(a)! ${c.toUpperCase()}');
//   }

//   if (cliente != null) {
//     print('Seja bem-vindo(a)! ${cliente.toUpperCase()}');
//   }
// }

// void funcao(
//   String a, // variável é obrigatória a declaração e posicional
//   String? b, // variável é obrigatória e posicional, porem pode receber null.
//   {
//   // variáveis dentro de {} são nomeáveis, ou seja, posso passar elas na ordem que eu quiser.
//   String? c = 'abc',
//   // variável c, do tipo String, ?pode ser nula, tem valor padrão 'abc', caso não seja passado um valor, não é obrigatório passar.
//   required String d,
//   // required serve para obrigar a declarar uma variável, mesmo que ela seja nomeável, não pode receber valor null pois não tem ? no final do String.
//   required String? e,
//   // diferente da variável D, essa variável E pode receber o valor de null, mas continua sendo obrigatória por conta do required.
//   String? f = 'qwe',
// }) {
//   print('a $a');
//   print('b $b');
//   print('c $c');
//   print('d $d');
//   print('e $e');
//   print('f $f');
// }

// FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS
// FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS
// FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS // FUNÇÕES ANONIMAS

// void main() {
//   saudacoes(repet);
//   // chamo a função saudações, e passo como parâmetro para a variavel corpo a função repet, ou seja, executará a funcao repet.
// }

// void saudacoes(Function corpo) {
//   // a variável corpo é do tipo Function, ou seja ela recebe como parâmetro uma função.
//   corpo(5); // esse valor 5 é atribuido ao parâmetro da variável i
// }

// void repet(int i) {
//   for (int j = 0; j < i; j++) {
//     print('Olá $j');
//   }
// }

// RETORNO DE FUNÇÕES COM NULLABLES // RETORNO DE FUNÇÕES COM NULLABLES // RETORNO DE FUNÇÕES COM NULLABLES
// RETORNO DE FUNÇÕES COM NULLABLES // RETORNO DE FUNÇÕES COM NULLABLES // RETORNO DE FUNÇÕES COM NULLABLES
// RETORNO DE FUNÇÕES COM NULLABLES // RETORNO DE FUNÇÕES COM NULLABLES // RETORNO DE FUNÇÕES COM NULLABLES

// void main() {
//   String nome = conta(5) ?? 'Não informado';
//   // a variável nome do tipo String, recebe o resultado da funcao conta, se o resultado da funcao conta for null, a funcao conta receberá o valor de 'Não informado'.
//   // conta(5) o 5 é o valor do x
//   // ?? 'Não informado' é o valor padrão caso a funcao conta não receba nenhum valor.
//   print(nome.toUpperCase());
// }

// String? conta(int x)
// // a funcao conta é do tipo String? e pode receber valor nulo
// {
//   if (x > 10) {
//     return 'Olá mundo!';
//   }
// } // se x não for maior que 10 ele retornará o valor nulo, que será substituído por 'Não informado'.

// ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO
// ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO
// ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO // ESCOPO

// int a = 0;
// void main() {
//   a = 10; // é possível alterar a variável A porquê ela está no escopo anterior a esse.

//   void funcao() {
//     a = 50; // é possível alterar a variável A porquê ela está no escopo anterior a esse.

//     int b = 5;
//     void funcao2(int c) {
//       b = 20; 
//       // é possível alterar a variável B porquê ela está no escopo anterior a esse.

//       int c = 30; 
//       // a preferência é dessa variável C e não da de cima.
//       print(c);
//     }

//     c = 40; // não é possível alterar a variável C porquê ela não está neste escopo (funcao), ela está no escopo (funcao2)
//   }

//   funcao(); // é possível acessar a essa funcao, pois ela foi declarada dentro desse escopo que eu estou chamando ela.
//   funcao2(); // não é possível acessar a essa funcao2, pois ela não foi criada dentro desse escopo que eu estou chamando ela.

//   b = 10; // não é possivel acessar essa variável porque ela não foi criada dentro desse escopo que eu estou tentando acessar.
// }

// VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS
// VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS
// VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS // VARIÁVEIS DINÂMICAS

// void main() {
//   var nome = 'Daniel';
//   // o tipo VAR identifica o tipo de valor que você está atribuindo para aquela variável.
//   nome = 'Ciolfi';
//   // só é possível alterar para o mesmo tipo da variável, que no caso ele identificou como String.
//   var idade = 40;
//   idade++;

//   dynamic variavel = 'Daniel';
//   // dynamic é um tipo de variável que aceita qualquer valor, inclusive pode ser alterado de String para Int, Bool, etc...
//   variavel = 3;
//   variavel = true;

//   num numero = 1.4;
//   // o tipo num, aceita números do tipo inteiro e decimais. (int e double)
// }

// LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS
// LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS
// LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS // LISTAS

// void main() {
//   List<dynamic> idades = ['Daniel', 'Ciolfi', false, 10, 1.1];
//   //Essa é uma lista dinâmica, que aceita qualquer tipo de dado.
//   List<String> idades2 = ['Daniel', 'Ciolfi'];
//   // Lista do tipo String, só aceitará valores Strings.
//   print(idades.length);
//   // o atributo .length conta quantos valores tem na lista.
//   print(idades.first); // pega o primeiro valor da lista.
//   print(idades.last); // pega o último valor da lista.
//   print(idades[0]);
//   // pega o valor através da posição, que no caso a primeira posição é 0, e assim por diante.
//   idades = [1, 2, 3];
//   print(idades);
//   // substituí a lista anterior pelos valores dados agora.
//   idades.add(2);
//   print(idades);
//   // adiciona no final da lista o número 2.
//   idades.addAll([5, 6, 7]);
//   print(idades);
//   // adiciona no final da lista os números inseridos.
// }

// LEITURA DA DOCUMENTAÇÃO // LEITURA DA DOCUMENTAÇÃO // LEITURA DA DOCUMENTAÇÃO
// LEITURA DA DOCUMENTAÇÃO // LEITURA DA DOCUMENTAÇÃO // LEITURA DA DOCUMENTAÇÃO
// LEITURA DA DOCUMENTAÇÃO // LEITURA DA DOCUMENTAÇÃO // LEITURA DA DOCUMENTAÇÃO

// FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS
// FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS
// FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS // FUNÇÕES DE LISTAS

// void main() {
//   List<int> idades = [1, 2, 4, 55, 33, 44, 22, 11, 23];

//   print(idades.length);
//   print(idades.first);
//   print(idades.last);
//   print(idades[3]);

//   idades.add(99);
//   idades.add(466);

//   List<int> outrasIdades = [567, 25, 4634];

//   idades.addAll(outrasIdades);
//   //ou pode fazer do jeito abaixo que é até mais fácil.
//   idades.addAll([32, 23, 45, 66, 77]);
//   print(idades);

//   idades.insert(0, -2);
//   // inseri na posição 0 o valor -2 na lista idades.
//   print(idades);
//   print(idades.contains(44));
//   // imprime true se o número 44 constar na lista, ou false se não constar.
//   print(idades.indexOf(44));
//   // imprime a posição do índice pesquisado.
//   print(idades.remove(33));
//   // vai remover da lista idades o número 33 e retornar o valor true do print.
//   print(idades);
//   print(idades.removeAt(3));
//   // remove o valor na posição 3, e retorna na tela o valor que foi removido;
//   idades.shuffle(); // mistura aleatoriamente os valores da lista.
//   print(idades);
//   idades.clear(); // limpa a lista por completo.
// }

// ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA
// ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA
// ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA // ITERAÇÃO DA LISTA

// void main() {
//   List<String> nomes = [
//     'Daniel',
//     'Ciolfi',
//     'Henrique',
//     'Giovana',
//     'Marcos',
//     'Eliane',
//     'Mariane'
//   ];
//   print(nomes);
//   print('\n');
//   // for (int i = 0; i < nomes.length; i++) {
//   //   print(nomes[i].toUpperCase());
//   // } // Enquanto i for menor que o (total de valores na lista nomes), i + 1
//   // imprime o valor da lista nome na posição i em letras MAIÚSCULAS.

//   for (String nome in nomes) {
//     print(nome.toUpperCase());
//   } // RECOMENDADA. a variável nome, assume cada valor da lista nomes, então vai imprimir cada valor da lista em letra maiúscula.
//   print('\n');

//   nomes.forEach((nome) {
//     print(nome.toUpperCase());
//   }); // semelhante ao de cima, pega todos os valores da lista nomes, coloca na variável nome, e depois imprime com o método .toUpperCase
//   print('\n');

//   nomes.sublist(2, 4).forEach((nome) {
//     print(nome.toUpperCase());
//   }); // semelhante ao de cima, pega todos os valores da lista nomes, coloca na variável nome, e depois imprime com o método .toUpperCase (porém começa da posição 2 e termina na 4)
// }

// OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA
// OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA
// OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA // OUTRAS FUNÇÕES DA LISTA

// void main() {
//   List<int> maluca = List.filled(100, 8);
//   // o método List.filled repete 100 vezes o valor desejado.
//   print(maluca);

//   List<int> doida = List.generate(5, funcao);
//   // o método List.generate repete 5 vezes o resultado da função.
//   print(doida);

//   List<int> doida2 = List.generate(10, (i) => i * 10);
//   // o método List.generate repete 10 vezes, o resultado da equação ao lado, o valor de i começa com 0 e termina em 9, isso depende do tanto de vezes que você coloca para repetir.
//   print(doida2);
//   print(doida2.isEmpty);
//   // retorna true se a lista estiver vazia.
//   print(doida2.isNotEmpty);
//   // retorna true se a lista não estiver vazia.
//   doida2.removeAt(0);
//   print(doida2.any((i) => i % 33 == 0));
//   // pega todos os valores da lista, e verifica se são divisíveis por 33, se algum numero for, retorna true, se não, retorna false.
//   print(doida2.firstWhere((i) => i % 40 == 0));
//   // retorna o primeiro número divisível por 40.
//   print(doida2.lastWhere((i) => i % 40 == 0));
//   // retorna o último número divisível por 40.
//   print(doida2.where((i) => i % 40 == 0));
//   // retorna todos os números que são divisíveis por 40.
//   print(doida2.map((i) => i + 1));
//   // pega cada valor da lista e soma + 1... e a lista fica com esse novo valor, pode ser utilizado qualquer outra lógica para criar a lista nova...
// }

// int funcao(int pos) {
//   return pos * 10;
//   // a variável pos, vai aumentando de 1 em 1 referente ao tanto de vezes que foi solicitada para repetir * List<int> doida = List.generate(5, funcao); * neste caso foram 5 vezes, ou seja, pos valerá 0,1,2,3,4...
// }

// LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY
// LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY
// LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY // LISTAS NO NULL-SAFETY

// void main() {
//   List<String?> lista0 = [
//     'Daniel',
//     null,
//     'Ciolfi',
//     null
//   ]; // aceita valores nulos.
//   print(lista0);

//   List<String>? lista2;
//   // com o ? do lado de fora dos <> quer dizer que a lista pode ser nula, ou seja, ela não existe ainda, então não é possível por exemplo, utilizar o método lista2.add('Qualquer valor')
//   if (lista2 != null) {
//     lista2.add('Ciolfi');
//   }

//   List<String> lista1 = []; // aqui eu declaro que a lista existe, porém vazia.
//   lista1.add('Daniel'); // adicionando um valor a minha lista.

//   List<String?>? lista3;
//   // o ? dentro dos <> diz que a lista pode receber valores nulos, e o ? fora do <> diz que a lista pode ser nula.
//   if (lista3 != null) {
//     // aqui só executaria, se a lista tivesse sido criada, mas como não foi, esse if é falso e não é executado.
//     lista3.add(null);
//     lista3.add('Qualquer valor');
//     print(lista3);
//   }
// }

// MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS
// MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS
// MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS // MAPAS

// void main() {
//   Map<int, String?> ddds = {
//     // O Map recebe uma chave e um valor, a chave aqui é do tipo INT pois são os DDDs, e o valor é uma String pois são as cidades, como tem ? dentro de <> aceita valores nulos nas cidades, nas chaves não.
//     11: 'São Paulo',
//     19: 'Campinas',
//     41: 'Curitiba',
//     49: null,
//   };
//   print(ddds[19]); // imprime o nome da cidade que tenha a chave 19.

//   String? cidade = ddds[11];
//   // cidade recebe o valor do DDD 11 que no caso é São Paulo.
//   print(cidade); // imprime São Paulo.

//   print(ddds.length); // conta quantas chaves possuem na lista.

//   ddds[61] = 'Brasilia';
//   // atribui a chave 61 com o valor 'Brasilia' no mapa ddds.
//   print(ddds);

//   ddds.remove(49); // remove a chave 49 e o valor dela do mapa ddds.
//   print(ddds);

//   print(ddds.values); // imprime somente os valores do map ddds.
//   print(ddds.keys); // imprime somente as chaves do map ddds.
//   print(ddds.containsKey(50));
//   // verifica se consta a chave 50 no map ddds, retorna true ou false.
//   print(ddds.containsValue('Brasilia'));
//   // verifica se consta o valor Brasilia no map ddds, retorna true ou false.
//   print(ddds.isEmpty);
//   // verifica se a lista esta vazia e retorna true ou false.


// // FUNÇÕES DE MAPAS E NULL ASSERTION // FUNÇÕES DE MAPAS E NULL ASSERTION // FUNÇÕES DE MAPAS E NULL ASSERTION
// // FUNÇÕES DE MAPAS E NULL ASSERTION // FUNÇÕES DE MAPAS E NULL ASSERTION // FUNÇÕES DE MAPAS E NULL ASSERTION
// // FUNÇÕES DE MAPAS E NULL ASSERTION // FUNÇÕES DE MAPAS E NULL ASSERTION // FUNÇÕES DE MAPAS E NULL ASSERTION

//   ddds.forEach((key, value) {
//     print('Key $key Value $value');
//     // pega cada chave e valor e imprime uma por uma.
//   });

//   //ddds.clear(); // limpa todo o mapa

//   ddds.addAll({90: 'Cidade Legal', 91: 'Cidade Chata'});
//   // adiciona no final do mapa, as chaves com seus respectivos valores.
//   print(ddds);

//   ddds.removeWhere((key, value) => key > 20);
//   // remove chave e valor, onde as chaves forem maiores que 20.
//   print(ddds);

//   String cidade1 = ddds[11]!;
//   // ! serve para dizer que ddds[11] não é nulo, só devo usar ! se eu tiver certeza que ddds[11] não é null, caso contrário uso IF ou ??
//   print(cidade1.toUpperCase());
// }

// MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY
// MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY
// MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY // MAPAS NO NULL-SAFETY

// void main() {
//   Map<int, String?>?
//       ddds2; // <?>? O mapa pode ser nullo, ainda não existe, posso crialo quando eu quiser, e quando criado, pode receber valores nullos.

//   if (ddds2 != null) {
//     // só irá remover, se o mapa já tiver sido criado.
//     ddds2.remove(11);
//     print(ddds2);
//   }

//   ddds2 = {
//     11: 'São Paulo',
//     19: 'Campinas',
//     41: 'Curitiba',
//     50: null,
//   }; // criei o mapa ddds2
// }

// JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON
//// JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON
///// JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON // JSON

// import 'dart:convert'; //importando bliblioteca de conversao.

// void main() {
//   Map<String, dynamic> dados = json.decode(dadosDoUsuario());
//   // Crio um mapa normal, a diferença é que ele recebe o valor de dadosDoUsuario() que é uma grande String, e o recurso json.decode, decodifica essa String para o meu mapa dados, sendo assim eu consigo fazer o acesso normal de um mapa.
//   print(dados['nome']);
//   print(dados['idade']);
//   print(dados['sobrenome']);
//   print(dados['endereco']['cidade']);
//   print(dados['endereco']['numero']);
//   print(dados['cursos'][0]['dificuldade']);
// }

// String dadosDoUsuario() {
//   // exemplo de um retorno de uma string de um servidor.
//   return """
//   {
//   "nome": "Daniel Henrique",
//   "sobrenome": "Ciolfi",
//   "idade": 50,
//   "casado": false,
//   "altura": 1.82,
//   "cursos": [
//     {
//       "nome": "Dart",
//       "dificuldade": 2
//     },
//     {
//       "nome": "Flutter",
//       "dificuldade": 2
//     },
//     "Python"
//   ],
//   "endereco": {
//     "cidade": "Campinas",
//     "pais": "Brasil",
//     "numero": 100
//   }
// }
// """;
// }

//EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH
//EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH
//EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH //EXCEPTIONS E TRY/CATCH

// void main() {
//   // tentar fazer o programa rodar por todas as instruções.
//   try {
//     // try quer dizer que vai tentar executar o código abaixo.
//     int resultado = 100 ~/ 2;
//     print(resultado);

//     double? valor = double.parse('50.2');
//     // a variável valor do tipo double? irá tentar receber a String '50.2a' e converter para double, se não conseguir, valor recebe null.
//     print(valor);
//   } on UnsupportedError {
//     // on UnsupportedError, aqui ele diz que se o erro do try, for do tipo UnsupportedError, ele executará o que estiver dentro desses {}.
//     print('Caiu aqui!');
//   } on FormatException catch (e) {
//     // se o erro do try, for do tipo FormatException, ele executará o que estiver dentro das {}, o catch (e) serve para trazer as informações do erro.
//     print('Caiu no erro -> ${e.message}');
//     print('Caiu no erro -> $e');
//   } catch (e) {
//     // se der algum tipo de erro no código do try e não for nenhum erro que esteja em algum ON, ele executará o catch, se o erro for simples, o código do try vai funcionar mesmo com erro.
//     print(e.runtimeType); // imprime o tipo de erro que deu no try
//   } finally {
//     // será executado independente se der erro ou não.
//     print('Final 22');
//   }
// }

// EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS
// EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS
// EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS // EXCEPTIONS PERSONALIZADAS

// void main() {
//   try {
//     // vai tentar executar a função teste.
//     teste(-10);
//     // - 10 é o parâmetro que eu passo para a funcao teste, ou seja x recebe -10.
//   } on VoceEstaFazendoBesteira {
//     // se o erro for do tipo VoceEstaFazendoBesteira, ele executará o código abaixo.
//     print('Besteira!');
//   } catch (e) {
//     print(e);
//   }
// }

// void teste(int x) {
//   if (x <= 0) {
//     throw VoceEstaFazendoBesteira();
//     // aqui se x for <= 0, eu jogo a exceção/erro VoceEstaFazendoBesteira.
//   }
//   print(x);
// }

// class VoceEstaFazendoBesteira implements Exception {
//   // criei a class VoceEstaFazendoBesteira do tipo Exception, ou seja, qualquer função que tenha ( throw VoceEstaFazendoBesteira(); ) e der erro de excessão, essa classe que representará a excessão.
//   @override
//   String toString() {
//     // essa será a mensagem para a excessão VoceEstaFazendoBesteira
//     return 'Você não pode passar um valor menor ou igual a 0';
//   }
// }

// ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES
// ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES
// ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES // ENUMERADORES

// enum StatusPagamento {
//   pendente,
//   pago,
//   reembolsado
// } // quando declarar um enumerador, não colocar ; no final

// void main() {
//   StatusPagamento status = StatusPagamento.pago;
//   // a variável status é do tipo Enumerador, ou seja, só receberá os valores que eu especifiquei e mais nenhum outro.
//   print(status);

//   switch (status) {
//     // ALT + ENTER (EM CIMA DO SWITCH) + ADD MISSING CASE CLAUSES, ele cria todos os CASES para as possibilidades de pagamento, no caso as possibilidades da variável status.
//     case StatusPagamento.pendente:
//       print('PENDENTE');
//       break;
//     case StatusPagamento.pago:
//       print('PAGO');
//       break;
//     case StatusPagamento.reembolsado:
//       print('REEMBOLSADO');
//       break;
//   }

//   print(status.index);
//   // isso converte o valor do meu enumerador dentro da variável status para o índice dele, nesse caso PAGO está na posição 1.
//   print(StatusPagamento.values[1]);
//   // aqui ele trás o valor do enumerador StatusPagamento através da posição, ou seja, a posição 1 é a do PAGO.
// }

// FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST
// FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST
// FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST // FINAL X CONST

// void main() {
//   // CONST.
//   const nome = 'Daniel';
//   // no caso a constante nome, sempre será Daniel, e não poderá ser trocada nunca, como nunca muda, não é necessário declarar o tipo, pois o Dart entende qual é o tipo.
//   const idade = 50;
//   const lista = ['Daniel', 'Ciolfi'];
//   // o mesmo funciona para lista e map, após declarado o valor, não é possível alterá-lo de maneira alguma.

//   // FINAL
//   final DateTime agora = DateTime.now();
//   //Final funciona em tempo de execução, ou seja, quando o código estiver rodando e chegar nessa parte, e a variávle receber o valor, não poderá mais ser alterada.
//   final String sobrenome;
//   // no final eu posso atribuir depois um valor para a variável sobrenome, porém após atribuir o valor ela não pode mais ser alterada.
//   if (nome == 'Daniel') {
//     sobrenome = 'Ciolfi';
//   } else {
//     sobrenome = 'Não sei';
//   }
// }

// OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA
// OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA
// OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA // OPERADORES CASCATA

// void main() {
//   List<String> nomes = [];

//   nomes
//     ..add('Daniel')
//     ..add('Ciolfi')
//     ..remove('Daniel');

//   print(nomes);
// }

// List<String> funcao(List<String> lista) {
//   return lista
//     ..add('Daniel')
//     ..add('Ciolfi')
//     ..remove('Daniel');
// }

// CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS
// CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS
// CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS // CLASSES, OBJETOS E ATRIBUTOS


// void main() {
//   Pessoa pessoa1 = Pessoa();
//   // criei o objeto pessoa1, do tipo Pessoa (só aceita os atributos da classe Pessoa), e instanciei a classe Pessoa();
//   pessoa1.nome = 'Daniel'; // nome do objeto (pessoa1) agora é 'Daniel'.
//   pessoa1.trocarNome('Henrique');
//   // usando o método trocarNome, ele altera o nome do objeto pessoa1.
//   pessoa1.idade = 40;
//   print(pessoa1.nome);
//   print(pessoa1.idade);
//   print(pessoa1.aniversario()); // imprimi / chamei o método aniversário
//   print(pessoa1.casar()); // imprimi / chamei o método casar.

//   Pessoa pessoa2 = Pessoa();
//   // aqui criei outro objeto e instanciei a mesma classe.
//   pessoa2.nome = 'Ciolfi'; // nome do objeto (pessoa2) agora é 'Ciolfi'.
//   pessoa2.idade = 30;
//   pessoa2.casado = true;
//   print(pessoa2.nome);
//   print(pessoa2.idade);
//   print(pessoa2.casado);
//   print(pessoa2.aniversario());
// }

// class Pessoa {
//   //  criei a classe Pessoa
//   String? nome; // nome, idade e casado são atributos, e não variáveis normais.
//   int? idade;
//   bool casado = false;

//   int? aniversario() {
//     // criei o método aniversário
//     print('Parabéns! $nome');
//     if (idade != null) {
//       idade = idade! + 1;
//     }
//     return idade; // retorna o valor da idade.
//   }

//   bool casar() {
//     casado = true;
//     return casado;
//   }

//   void trocarNome(String n) {
//     nome = n;
//   }
// }


// CONSTRUTORES E CONSTRUTORES NOMEADOS // CONSTRUTORES E CONSTRUTORES NOMEADOS // CONSTRUTORES E CONSTRUTORES NOMEADOS
// CONSTRUTORES E CONSTRUTORES NOMEADOS // CONSTRUTORES E CONSTRUTORES NOMEADOS // CONSTRUTORES E CONSTRUTORES NOMEADOS
// CONSTRUTORES E CONSTRUTORES NOMEADOS // CONSTRUTORES E CONSTRUTORES NOMEADOS // CONSTRUTORES E CONSTRUTORES NOMEADOS

// void main() {
//   Pessoa pessoa1 = Pessoa.solteira(nome: 'Daniel', idade:40); // após criar o construtor, e declarar obrigatório esses parâmetros, eu passo ele assim que instancio a classe.
//   print(pessoa1.nome);
//   print(pessoa1.idade);
//   print(pessoa1.aniversario());
//   print(pessoa1.casar());

//   Pessoa pessoa2 = Pessoa.casada(nome: 'Ciolfi', idade: 30); // após criar o construtor, e declarar obrigatório esses parâmetros, eu passo ele assim que instancio a classe.
//   print(pessoa2.casado);
//   print(pessoa2.nome);
//   print(pessoa2.idade);
//   print(pessoa2.aniversario());
// }

// class Pessoa {

//   Pessoa({required this.nome, required this.idade, this.casado = false}) {
//     print('Criando o $nome com idade $idade');
//   } // Isso é um construtor, e agora ele me obriga a passar por parâmetro, o nome e a idade do objeto assim que instancio.

//   Pessoa.casada({required this.nome, required this.idade, this.casado = true});
//   // Construtor nomeado, porém o atributo casado recebe como default true, ou sejá é casado, então esse método eu uso para o objeto que for casado.

//   Pessoa.solteira({required this.nome, required this.idade, this.casado = false});
//   // Construtor nomeado, porém o atributo casado recebe como default false, ou sejá é solteiro(a), então esse método eu uso para o objeto que for solteiro(a).

//   String nome;
//   int idade;
//   bool casado;

//   int? aniversario() {
//     print('Parabéns! $nome');
//     idade++;
//     return idade;
//   }

//   bool casar() {
//     casado = true;
//     return casado;
//   }
// }

// PROGRAMA CRIADO POR RENATO // PROGRAMA CRIADO POR RENATO // PROGRAMA CRIADO POR RENATO
// PROGRAMA CRIADO POR RENATO // PROGRAMA CRIADO POR RENATO // PROGRAMA CRIADO POR RENATO
// PROGRAMA CRIADO POR RENATO // PROGRAMA CRIADO POR RENATO // PROGRAMA CRIADO POR RENATO

// void main() {
//   Casa casa1 = Casa.padrao(cor: 'amarela', preco: 2.50, vendida: true);
//   {
//     print('\n');
//   }

//   Casa casa2 = Casa.preco(cor: 'Azul', vendida: false);
//   {
//     print('\n');
//   }

//   Casa casa3 = Casa.vendida(cor: 'Verde', preco: 10.30);
//   {
//     print('\n');
//   }
// }

// class Casa {
//   // ATRIBUTOS
//   bool banheiro;
//   bool sala;
//   bool cozinha;
//   String cor;
//   double preco;
//   bool vendida;

//   // CONSTRUTORES NOMEADOS
//   Casa.padrao(
//       {required this.cor,
//       required this.preco,
//       required this.vendida,
//       this.banheiro = true,
//       this.sala = true,
//       this.cozinha = true}) {
//     print('PADRÃO + $cor, $preco, $vendida');
//   }

//   Casa.cor(
//       {this.cor = 'amarela',
//       required this.preco,
//       required this.vendida,
//       this.banheiro = true,
//       this.sala = true,
//       this.cozinha = true}) {
//     print('Casa amarela + $preco, $vendida, + PADRÃO');
//   }

//   Casa.preco(
//       {required this.cor,
//       this.preco = 51.50,
//       required this.vendida,
//       this.banheiro = true,
//       this.sala = true,
//       this.cozinha = true}) {
//     print('Casa de 51.50, $cor, $vendida, + PADRÃO');
//   }

//   Casa.vendida(
//       {required this.cor,
//       required this.preco,
//       this.vendida = true,
//       this.banheiro = true,
//       this.sala = true,
//       this.cozinha = true}) {
//     print('Casa vendida, $cor, $preco, + PADRÃO');
//   }
//   //COM OS CONSTRUTORES NOMEADOS, EU CRIO O OBJETO E PADRONIZO OS ATRIBUTOS QUE NÃO IRÃO MUDAR, E COLOCO REQUIRED NOS QUE PRECISAM DE VALORES.
// }

// GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS
// GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS
// GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS // GETTERS E SETTERS

// void main() {
//   Pessoa pessoa1 = Pessoa(nome: 'Daniel', idade: 40);
//   Pessoa pessoa2 = Pessoa(nome: 'Ciolfi', idade: 30);

//   pessoa1.dinheiro = 300; // (SETTER) a variável dinheiro aqui é usada no setter (lá em baixo) para setar um valor no atributo privado _dinheiro.
//   pessoa2.dinheiro = 10000; // (GETTER )a variável dinheiro aqui é usada no setter (lá em baixo) para setar um valor no atributo privado _dinheiro.

//   print(pessoa1.dinheiro); // print está funcionando por conta do getter(get)
//   print(pessoa2.dinheiro);
// }

// class Pessoa {
//   Pessoa({required this.nome, required this.idade, this.casado = false}) {
//     print('Criando o $nome com idade $idade'); // imrpime para todos os objetos instânciados.
//   }

//   String nome;
//   int idade;
//   bool casado;

//   double? _dinheiro; // _ esse atributo agora é privado.

//   set dinheiro(double? valor) // a variável dinheiro está recebendo a variável valor como parâmetro
//   {
//     // isso é um Setter, serve para modificar um atributo que esteja privado e você queira realizar uma validação ou outra ação.
//     if (valor != null && valor >= 0 && valor < 1000) {
//       print('Modificando dinheiro do $nome');
//       _dinheiro = valor; // o objeto que for aceito no if, receberá _dinheiro
//     }
//   }

//   double? get dinheiro {
//     // serve para ler um valor diretamente em um local.
//     print('Lendo dinheiro do $nome');
//     return _dinheiro;
//   }
// }

// ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE
// ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE
// ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE // ATRIBUTOS NULLABLE

// void main() {
//   Pessoa pessoa1 = Pessoa(nome: 'Daniel', idade: 40);
//   Pessoa pessoa2 = Pessoa(nome: 'Ciolfi', idade: 30);

//   pessoa1.dinheiro = 300; // estou passando o parâmetro valor para o set dinheiro.
//   pessoa2.dinheiro = 100;

//   print(pessoa1.aniversario()); // print/chamei o método aniversario para o objeto pessoa1
//   pessoa2.casar(); // chamei o método casar para o objeto pessoa2
//   print(pessoa2.casado); // print objeto pessoa2 e atributo casado.

//   String? nome = pessoa1.nomeSecreto; // após eu ler pessoa1.nomeSecreto; , o get transformou ele em null, por isso eu tenho que atribuir o valor dele a variável nome, para conseguir ler novamente porém em uma variável.
//   if (nome != null) {
//     print(nome.toUpperCase());
//   }

//   print(pessoa1.nomeSecreto); // após ler uma vez o nomeSecreto, o get transformou ele em null.

//   if (pessoa1.atributo != null) {
//     print(pessoa1.atributo!.toUpperCase()); // o ! diz que o atributo atributo não é null.
//   }
// }

// class Pessoa {
//   Pessoa({required this.nome, required this.idade, this.casado = false}) {
//     print('Criando o $nome com idade $idade');
//   }

//   String nome;
//   int idade;
//   bool casado;

//   double _dinheiro = 0; // _ esse atributo agora é privado.

//   String? _nomeSecreto = 'Flutter';

//   String? atributo = 'Olá';

//   get nomeSecreto {
//     // esse get só permite ler o atributo uma vez, e depois ele passa a ser null.
//     String? nome = _nomeSecreto;
//     if (nome != null) {
//       _nomeSecreto = null;
//       return nome;
//     } else {
//       return null;
//     }
//   }

//   int aniversario() {
//     print('Parabéns! $nome');
//     idade++;
//     return idade;
//   }

//   void casar() {
//     casado = true;
//   }

//   set dinheiro(double valor)
//     // passei o parâmetro valor lá em cima no código
//   {
//     // isso é um Setter, serve para modificar um atributo que esteja privado e você queira realizar uma validação ou outra ação.
//     if (valor >= 0 && valor < 1000) {
//       print('Modificando dinheiro do $nome');
//       _dinheiro = valor; //o atributo privado _dinheiro recebe o parâmetro da variável valor.
//     }
//   }

//   double get dinheiro {
//     // serve para ler um valor diretamente em um local.
//     print('Lendo dinheiro do $nome');
//     _dinheiro -= 100;
//     return _dinheiro;
//   }
//   // Sempre que eu ler atributos de objetos, esses atributos podem mudar a vontade cada vez que eu ler sem eu fazer nada, se precisar verificar se algo é diferente de null, devo criar uma variável local.
// }

// MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC
// MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC
// MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC // MODIFICADOR STATIC

// void main() {

//   Pessoa.alturaPadrao = 1.80;

//   Pessoa pessoa1 = Pessoa(nome: 'Daniel', idade: 40);
//   print(pessoa1.nome);
//   print(pessoa1.idade);
//   print(pessoa1.altura);
//   pessoa1.comer();

//   Pessoa.atributoStatic = ', Daniel';
//   print(Pessoa.atributoStatic);
//   print(Pessoa.metodoStatic());
// }

// class Pessoa {
//   Pessoa({required this.nome, required this.idade}); // coloquei como obrigatório (required) os atributos nome e idade

//   String nome; // atributos
//   int idade;
//   double altura = alturaPadrao;

//   void comer() { // método
//     print('Comendo...');
//   }

//   static String atributoStatic = 'abc'; // esse atributo pertence a classe Pessoa, e não ao objeto igual os anteriores
//   static String metodoStatic() { // esse método pertence a classe Pessoa, é possível ler um atributo static nele também
//     return 'Olá mundo $atributoStatic';
//     }

//   static double alturaPadrao = 0; // atributo static, é útil quando eu preciso configurar coisas (atributos) padrões, pois quando eu seto ele antes de criar um objeto, quando eu criar o objeto, o objeto já virá com alguns atributos padrões.
//   }

// MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE
// MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE
// MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE // MODIFICADOR LATE

// void main() {

//   Pessoa pessoa1 = Pessoa(nome: 'Daniel', idade: 40); {}
//   pessoa1.cpf = '36139891825';
//   print(pessoa1.cpf);
//   print(pessoa1.temperatura); // chamando o atributo temperatura que é late, posso passar o valor quando for usá-lo.
//   print(pessoa1.temperatura);
//   print(pessoa1.temperatura);

//   print(pessoa1.temperatura2); // chamando o atributo temperatura2 que é um get, (recomendado quando for ficar mudando o atributo temperatura2, pois ele executa o get por completo toda vez que for chamado, diferente do late que só executa na primeira vez, e nas próximas só usa o valor do atributo.)
//   print(pessoa1.temperatura2);
//   print(pessoa1.temperatura2);
// }

// class Pessoa {

//   Pessoa({required this.nome, required this.idade,});

//   String nome;
//   int idade;
//   late String cpf; // late quer dizer que esse atributo pode ser inicializado quando eu quiser, porém antes de ele ser utilizado.

//   late double temperatura = medirTemperatura(); // o atributo temperatura pode receber o valor quando quiser, porém antes de ser utilizado, a diferença de late para o get, é que o get é executado toda vez que for chamado, o late uma só...

//   double get temperatura2 => medirTemperatura(); // quando o get é chamado lá em cima, ele é executado e coloca o valor no atributo temperatura2, e quando é chamado de novo, coloca de novo o valor no atributo temperatura 2, ou seja ele repete todo o processo ao invés de só usar o valor do atributo.

//   double medirTemperatura() {
//     print('Mediu a temperatura');
//     return 37.0;
//   }
// }

// OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?.
// OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?.
// OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?. // OPERADOR ?.

// void main() {
//   // Pessoa? pessoa2;
//   Pessoa? pessoa2 = Pessoa(nome: 'Renato', idade: 26); // criei o objeto pessoa2 do tipo Pessoa?, ou seja esse objeto pode ser inicializado null.
//   print(pessoa2?.nome.toUpperCase()); // vai printar null caso não tenha colocado um valor no atributo nome.
//   print(pessoa2?.idade);
//   print(pessoa2?.cidade?.toUpperCase());
//   pessoa2?.comer();

// }

// class Pessoa {
//   Pessoa({required this.nome, required this.idade,});

//   String nome;
//   int idade;
//   String? cidade;

//   void comer() {
//     print('comendo');
//   }
// }

// PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA
// PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA
// PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA // PASSAGEM DE REFERÊNCIA

// void main() {
//   Pessoa pessoa1 = Pessoa(nome: 'Daniel', idade: 40);
//   print(pessoa1.nome);
//   print(pessoa1.idade);

//   Pessoa pessoa2 = Pessoa(nome: 'Ciolfi', idade: 25);
//   print(pessoa2.nome);
//   print(pessoa2.idade);

//   funcao(pessoa1); // chamei a funcao funcao e passei o objeto pessoa1 como parâmetro.
//   print(pessoa1.idade);

//   int numero = 10;
//   funcao2(numero); // chamei a funcao funcao2, e passei por parâmetro a variável numero(que vale 10), mesmo que eu mexa na variável x, a variável numero que será o parâmetro...
//   print(numero);
// }

//   void funcao(Pessoa pessoa) { // essa funcao, faz acrescentar +1 na idade do objeto i.
//   pessoa.idade++;
// }

// void funcao2(int x) {
//   x = 20;
// }

// class Pessoa {
//   Pessoa({required this.nome, required this.idade});

//   String nome;
//   int idade;
// }

// HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA
// VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA
// HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA // HERANÇA
// VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA // VANTAGENS DA HERANÇA

// void main() {

//   Cachorro cachorro1 = Cachorro();
//   cachorro1.nome = 'Rex';
//   cachorro1.idade = 3;
//   cachorro1.comer();
//   cachorro1.dormir(); // todos os métodos acima foram extendidos (herança) da classe Animal.
//   cachorro1.latir(); // método da classe Cachorro, só pode ser acessado da classe Cachorro.

//   Gato gato1 = Gato();
//   gato1.nome = 'Bixano';
//   gato1.idade = 5;
//   gato1.comer();
//   gato1.dormir(); // todos os métodos acima foram extendidos (herança) da classe Animal.
//   gato1.miar(); // todos os métodos/variáveis abaixo são somente da classe gato, e só podem ser acessador por essa classe.
//   gato1.vidas--;
//   print(gato1.vidas);

//   List<Animal> animais= []; // Essa lista aceita qualquer objeto que extenda (herde) a classe animal.
//   animais.add(cachorro1);
//   animais.add(gato1);

//   // Animal animal1 = animais.first; // variável animal1 está recebendo o primeiro valor da List<Animal>
//   Animal animal1 = funcao(); // animal1 recebe o retorno da função, que é Cachorro.
//   if(animal1 is Cachorro) { // se animal1 for do tipo Cachorro, execute o método abaixo.
//   animal1.latir(); // só trás os métodos extendidos (herança da classe Animal) e próprios da classe Cachorro.
//   } else if(animal1 is Gato) { // se não se variável animal1 for do tipo Gato
//     animal1.miar();
//   }
// }

// Animal funcao() {
//   return Cachorro();
// }

// class Animal {
//   String? nome;
//   int? idade;

//   void comer() {
//   print('Comeu');
// }

//   void dormir() {
//     print('Dormiu');
//   }
// }

// class Cachorro extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Cachorro.

//   void latir() {
//   print('Au au');
//   }
// }

// class Gato extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Gato.

//   int vidas = 7;
//   void miar() {
//     print('Miaaaau');
//   }
// }

// REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS
// REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS
// REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS // REESCRITA DE MÉTODOS

// void main() {

//   Cachorro cachorro1 = Cachorro();
//   cachorro1.nome = 'Rex';
//   cachorro1.idade = 3;
//   cachorro1.comer();
//   cachorro1.dormir(); // todos os métodos acima foram extendidos (herança) da classe Animal.
//   cachorro1.latir(); // método da classe Cachorro, só pode ser acessado da classe Cachorro.

//   print(cachorro1); // isso quer dizer que ele sempre irá chamar o método toString, ou seja ficaria assim print(cachorro1.toString());

//   Gato gato1 = Gato();
//   gato1.nome = 'Bixano';
//   gato1.idade = 5;
//   gato1.comer();
//   gato1.dormir(); // todos os métodos acima foram extendidos (herança) da classe Animal.
//   gato1.miar(); // todos os métodos/variáveis abaixo são somente da classe gato, e só podem ser acessador por essa classe.
//   gato1.vidas--; // -- significa subtrair 1.
//   print(gato1.vidas);

//   print(gato1); // isso quer dizer que ele sempre irá chamar o método toString, ou seja ficaria assim print(cachorro1.toString());
// }

// class Animal {
//   String? nome;
//   int? idade;

//   void comer() {
//   print('Comeu');
// }

//   void dormir() {
//     print('Dormiu');
//   }

//   @override
//   String toString() { // aqui estou subscrevendo o método toString
//   return 'Nome: $nome Idade $idade';
//   }

// }

// class Cachorro extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Cachorro.

//   void latir() {
//   print('Au au');
//   }
//   @override //significa que eu estou subscrevendo o método da Super Classe Animal, por esse método abaixo.
//   void dormir() { // devo escrever o método igual ele está na classe Animal
//     print('Dormiu rocando muito!!!'); // agora o método dormir do objeto cachorro é este, e não mais o da classe Animal.
//   }

//   @override
//   String toString() { // aqui estou subscrevendo o método toString
//     return 'Cachorro - Nome: $nome Idade $idade';
//   }
// }

// class Gato extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Gato.

//   int vidas = 7;
//   void miar() {
//     print('Miaaaau');
//   }

//   @override
//   String toString() { // aqui estou subscrevendo o método toString
//     return 'Gato - Nome: $nome Idade $idade';
//   }
// }

// KEYWORD SUPER

// void main() {
//   Cachorro cachorro1 = Cachorro('Rex', 3);
//   print(
//       cachorro1); // isso quer dizer que ele sempre irá chamar o método toString, ou seja ficaria assim print(cachorro1.toString());

//   Gato gato1 = Gato('Bixano', 5);
//   print(
//       gato1); // isso quer dizer que ele sempre irá chamar o método toString, ou seja ficaria assim print(cachorro1.toString());
// }

// class Animal {
//   Animal(this.nome, this.idade); // construtor

//   String nome;
//   int idade;

//   void comer() {
//     print('Comeu');
//   }

//   void dormir() {
//     print('Dormiu');
//   }
// }

// class Cachorro extends Animal {
//   // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Cachorro.

//   // o super é utilizado para acessar os atributos, métodos, construtores, getters e setters que tivermos na nossa Super Classe, que nesse caso é a Class Animal.
//   Cachorro(String nome, int idade)
//       : super(nome,
//             idade) // CONSTRUTOR | aqui ele está acessando o nome e idade da Super Class Animal, e passando os atributos nome e idade para o objeto criado na Classe Cachorro.
//   {
//     print('Criou o cachorro $nome');
//   }

//   void latir() {
//     print('Au au');
//   }

//   @override //significa que eu estou subscrevendo o método da Super Classe Animal, por esse método abaixo.
//   void dormir() {
//     // devo escrever o método igual ele está na classe Animal
//     super
//         .dormir(); // aqui ele está chamando o método original, da super classe Animal, e depois o método subcrevido que é o que está abaixo.
//     print(
//         'Rocando muito!!!'); // agora o método dormir do objeto cachorro é este, e não mais o da classe Animal.
//   }

//   @override
//   String toString() {
//     // aqui estou subscrevendo o método toString
//     return 'Cachorro - Nome: $nome Idade $idade';
//   }
// }

// class Gato extends Animal {
//   // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Gato.

//   // o super é utilizado para acessar os atributos, métodos, construtores, getters e setters que tivermos na nossa Super Classe, que nesse caso é a Class Animal.
//   Gato(String nome, int idade)
//       : super(nome,
//             idade) // CONSTRUTOR | aqui ele está acessando o nome e idade da Super Class Animal, e passando os atributos nome e idade para o objeto criado na Classe gato.
//   {
//     print('Criou o cachorro $nome');
//   }

//   int vidas = 7;
//   void miar() {
//     print('Miaaaau');
//   }

//   @override
//   String toString() {
//     // aqui estou subscrevendo o método toString
//     return 'Gato - Nome: $nome Idade $idade';
//   }
// }

// OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST
// OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST
// OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST // OPERADOR CAST

// void main() {

//   Cachorro cachorro1 = Cachorro('Rex', 3);

//   print(cachorro1); // isso quer dizer que ele sempre irá chamar o método toString, ou seja ficaria assim print(cachorro1.toString());

//   Gato gato1 = Gato('Bixano', 5);

//   print(gato1); // isso quer dizer que ele sempre irá chamar o método toString, ou seja ficaria assim print(cachorro1.toString());

//   Cachorro animal1 = funcao() as Cachorro; // Operador cast é o as.
//   animal1.latir(); // esse operador as está fazendo a mesma coisa que o código abaixo.

// //  Animal animal1 = funcao();
// //   if(animal1 is Cachorro) {
// //     animal1.latir();
// //   }
// }

// Animal funcao() {
//   return Cachorro('Cat', 7);
// }

// class Animal {

//   Animal(this.nome, this.idade); // construtor

//   String nome;
//   int idade;

//   void comer() {
//   print('Comeu');
// }

//   void dormir() {
//     print('Dormiu');
//   }

// }

// class Cachorro extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Cachorro.

//   // o super é utilizado para acessar os atributos, métodos, construtores, getters e setters que tivermos na nossa Super Classe, que nesse caso é a Class Animal.
//   Cachorro(String nome, int idade) : super(nome, idade) // aqui ele está acessando o nome e idade da Super Class Animal, e passando os atributos nome e idade para o objeto criado na Classe Cachorro.
//   {
//     print('Criou o cachorro $nome');
//   }

//   void latir() {
//   print('Au au');
//   }

//   @override //significa que eu estou subscrevendo o método da Super Classe Animal, por esse método abaixo.
//   void dormir() { // devo escrever o método igual ele está na classe Animal
//     super.dormir(); // aqui eles está chamando o método original, da super classe Animal, e depois o método subcrevido que é o que está abaixo.
//     print('Rocando muito!!!'); // agora o método dormir do objeto cachorro é este, e não mais o da classe Animal.
//   }

//   @override
//   String toString() { // aqui estou subscrevendo o método toString
//     return 'Cachorro - Nome: $nome Idade $idade';
//   }
// }

// class Gato extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Gato.

//   // o super é utilizado para acessar os atributos, métodos, construtores, getters e setters que tivermos na nossa Super Classe, que nesse caso é a Class Animal.
//   Gato(String nome, int idade) : super(nome, idade) // aqui ele está acessando o nome e idade da Super Class Animal, e passando os atributos nome e idade para o objeto criado na Classe gato.
//   {
//   print('Criou o cachorro $nome');
//   }

//   int vidas = 7;
//   void miar() {
//     print('Miaaaau');
//   }

//   @override
//   String toString() { // aqui estou subscrevendo o método toString
//     return 'Gato - Nome: $nome Idade $idade';
//   }
// }

// CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS
// CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS
// CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS // CLASSES ABSTRATAS

// void main() {

//   Cachorro cachorro1 = Cachorro('Rex', 3);
//   cachorro1.morrer();

//   Gato gato1 = Gato('Bixano', 5);
//   gato1.morrer();
// }

// abstract class Animal { // tornei a classe abstrata, não posso instanciar essa classe.

//   Animal(this.nome, this.idade); // construtor

//   String nome;
//   int idade;

//   void comer() {
//   print('Comeu');
// }

//   void dormir() {
//     print('Dormiu');
//   }

//   void morrer(); // quando eu só crio o método, mas não passo nada pra ele, eu tenho que passar ele nas classes.

// }

// class Cachorro extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Cachorro.

//   // o super é utilizado para acessar os atributos, métodos, construtores, getters e setters que tivermos na nossa Super Classe, que nesse caso é a Class Animal.
//   Cachorro(String nome, int idade) : super(nome, idade) // aqui ele está acessando o nome e idade da Super Class Animal, e passando os atributos nome e idade para o objeto criado na Classe Cachorro.
//   {
//     print('Criou o gato $nome');
//   }

//   void latir() {
//   print('Au au');
//   }

//   @override //significa que eu estou subscrevendo o método da Super Classe Animal, por esse método abaixo.
//   void dormir() { // devo escrever o método igual ele está na classe Animal
//     super.dormir(); // aqui eles está chamando o método original, da super classe Animal, e depois o método subcrevido que é o que está abaixo.
//     print('Rocando muito!!!'); // agora o método dormir do objeto cachorro é este, e não mais o da classe Animal.
//   }

//   @override
//   void morrer() {
//     print('Muito triste :('); // estou passando esse método aqui, pois na Super Classe eu só criei ele, porém sem nenhuma ação.
//   }
// }

// class Gato extends Animal { // aqui eu estou herdando os atributos e métodos da classe Animal, para a classe Gato.

//   // o super é utilizado para acessar os atributos, métodos, construtores, getters e setters que tivermos na nossa Super Classe, que nesse caso é a Class Animal.
//   Gato(String nome, int idade) : super(nome, idade) // aqui ele está acessando o nome e idade da Super Class Animal, e passando os atributos nome e idade para o objeto criado na Classe gato.
//   {
//   print('Criou o cachorro $nome');
//   }

//   int vidas = 7;
//   void miar() {
//     print('Miaaaau');
//   }

//   @override
//   void morrer() {
//     vidas--;
//     print('Sobrou $vidas vidas'); // estou passando esse método aqui, pois na Super Classe eu só criei ele, porém sem nenhuma ação.
//   }
// }

// INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES
// INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES
// INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES // INTERFACES

// void main() {
//   // RepositorioPessoas repo = RepositorioPessoasLocal();
//   RepositorioPessoas repo =
//       RepositorioPessoasRemote(); // Posso trocar de instância RepositorioPessoasRemote para RepositorioPessoasLocal, pois é a mesma interface que veio da RepositorioPessoas.
//   repo.ler(10);
//   repo.adicionar('Ciolfi');
//   repo.apagar(5);
// }

// abstract class RepositorioPessoas {
//   String ler(int i);
//   void adicionar(String nome);
//   void apagar(int i);
//   void apagarTodos();
// }

// class RepositorioPessoasRemote implements RepositorioPessoas {
//   // implements quer dizer que vai usar a mesma interface do RepositorioPessoas.
//   @override // ALT + ENTER EM CIMA DE RepositorioPessoasRemote para criar a mesma interface da Super Classe RepositorioPessoas.
//   void adicionar(String nome) {}

//   @override
//   void apagar(int i) {}

//   @override
//   String ler(int i) {
//     return 'Ciolfi';
//     throw UnimplementedError();
//   }

//   @override
//   void apagarTodos() {}
// }

// class RepositorioPessoasLocal implements RepositorioPessoas {
//   // implements quer dizer que vai usar a mesma interface do RepositorioPessoas.
//   @override
//   void adicionar(String nome) {}

//   @override
//   void apagar(int i) {}

//   @override
//   String ler(int i) {
//     return 'Daniel';
//     throw UnimplementedError();
//   }

//   @override
//   void apagarTodos() {}
// }


// OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES 
// OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES 
// OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES // OUTRO USO PARA INTERFACES 


// void main() {
//   Movel movel1 = Pessoa();
//   movel1.frente();
//   movel1.esquerda();
  
//   //Vendivel vend1 = Carro();
//   Vendivel vend1 = Geladeira();
//   print(vend1.preco());  
// }

// class Geladeira implements Vendivel {
//   @override
//   double preco() {
//   return 1000;
//   }
  
// }

// class Pessoa implements Movel {
  
//   String? nome;
//   @override
//   void direita() {}

//   @override
//   void esquerda() {}

//   @override
//   void frente() {}
  
// }

// class Carro implements Movel, Vendivel { // é possível implementar duas classes (interfaces), mas não é possível herdar duas classes.
  
//   String? modelo;
  
//   @override
//   void direita() {}

//   @override
//   void esquerda() {}

//   @override
//   void frente() {}

//   @override
//   double preco() {
//     return 50000;
//   }
  
// }

// abstract class Movel {
//   void frente();
//   void esquerda();
//   void direita();
// }

// abstract class Vendivel {
//   double preco();
// }


// ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE
// ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE
// ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE // ENTENDENDO STATEFUL E CLASSE

// import 'package:flutter/material.dart';

// void main() {
//   runApp(MyApp(
//     nome: 'João', // passando o atributo/propriedade (nome) por parâmetro.
//   ));
// }

// class MyApp extends StatefulWidget {
//   late String nome;
//   // inserindo o atributo/propriedade da classe, do tipo late (pode ser recebido depois...)
//   MyApp({Key? key, required this.nome}) : super(key: key);
//   // colocando o atributo/propriedade como obrigatório no Construtor da minha classe, ou seja, agora tenho que passar ele por parâmetro obrigatóriamente...

//   @override
//   _MyAppState createState() => _MyAppState();
// }

// class _MyAppState extends State<MyApp> {
//   int salario = 7000;

//   void aumentaSalario(int valor) {
//     setState(() {
//       // setState recria o Widget build.
//       salario = salario + valor;
//     });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Center(
//       child: GestureDetector(
//         //Detector de gesto, onTap = 1click, ou seja quando eu clicar no Text, ele executa o que estiver dentro do onTap.
//         onTap: () {
//           aumentaSalario(200);
//         },
//         child: Text(
//           'O salário de ${widget.nome} é $salario', // ${widget.nome} é para eu utilizar o atributo/propriedade da classe MyApp
//           textDirection:
//               TextDirection.ltr, // direção do texto, esquerda para direita.
//           style: TextStyle(fontSize: 30),
//         ),
//       ),
//     );
//   }
// }



// import 'package:flutter/cupertino.dart';
// import 'package:flutter/material.dart';

// void main() {
//   int valor = 10;
//   runApp(
//     MyApp(
//       title: 'Aplicativo Olá Mundo',
//       valor: valor,
//     ),
//   );
// }

// class MyApp extends StatelessWidget {
//   final String title;
//   final int valor;
//   const MyApp({Key? key, required this.title, required this.valor})
//       : super(key: key);

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       home: Scaffold(
//         appBar: AppBar(
//           title: Text(title),
//         ),
//         body: Center(
//           child: Text(
//             'olá mundo, valor é ' + valor.toString(),
//             style: const TextStyle(fontSize: 50, color: Colors.black),
//           ),
//         ),
//       ),
//     );
//   }
// }

